<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Paper Layout Organizer</title>
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700" rel="stylesheet" />
    <style>
        :root {
            --primary-color: #007bff;
            --background-color: #f7f9fc;
            --paper-background: #ffffff;
            --frame-background: rgba(0, 123, 255, 0.1);
            --text-color: #333;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background: var(--background-color);
            margin: 0;
            padding: 20px;
            color: var(--text-color);
        }
        h2 {
            margin: 0 0 10px;
        }
        #controls {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 40px;
            align-items: flex-start;
        }
        #controls > div {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        label {
            font-weight: 500;
            margin-right: 5px;
        }
        input[type="number"],
        input[type="text"],
        select {
            padding: 6px 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100px;
        }
        input[type="text"] {
            width: 150px;
        }
        button {
            padding: 8px 15px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            background: var(--primary-color);
            color: #fff;
            cursor: pointer;
            transition: background 0.3s ease;
            align-self: flex-start;
        }
        button:hover {
            background: #0056b3;
        }
        #paper {
            position: relative;
            margin: 0 auto 20px auto;
            background: var(--paper-background);
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        /* Use top left as transform origin to avoid clipping after rotations */
        .frame {
            position: absolute;
            border: 2px solid var(--primary-color);
            background: var(--frame-background);
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            box-sizing: border-box;
            cursor: move;
            transition: box-shadow 0.2s ease;
            transform-origin: center;
        }
        .frame.dragging {
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        /* Frame Tracker styling */
        #frameTracker {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        #frameTracker table {
            width: 100%;
            border-collapse: collapse;
        }
        #frameTracker th,
        #frameTracker td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        #frameTracker th {
            background-color: #f0f0f0;
        }
        .frame-id-cell {
            cursor: text;
        }
        /* Make width and height cells editable */
        .dim-cell {
            cursor: text;
        }
        .delete-btn {
            background: #dc3545;
            border: none;
            border-radius: 4px;
            color: #fff;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }
        .delete-btn:hover {
            background: #c82333;
        }
        #deleteAllFrames,
        #undoAction {
            margin-bottom: 10px;
            background: #dc3545;
        }
        #undoAction {
            background: #6c757d;
        }
        #undoAction:hover {
            background: #5a6268;
        }
        .scale-info {
            font-size: 12px;
            color: #555;
            margin-left: 5px;
        }
        .rotate-slider {
            width: 100px;
        }
        .rotate-value {
            font-size: 12px;
            margin-left: 5px;
        }
        #paperSizeOutput {
            margin-top: 10px;
            font-size: 14px;
            color: #333;
            border: 1px solid #ccc;
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
            background: #fff;
        }
    </style>
</head>
<body>

<div id="controls">
    <!-- Paper Settings -->
    <div>
        <h2>Paper Settings</h2>
        <div>
            <label for="paperWidth">Width:</label>
            <input type="number" id="paperWidth" value="800" />
        </div>
        <div>
            <label for="paperHeight">Height:</label>
            <input type="number" id="paperHeight" value="600" />
        </div>
        <div>
            <label for="paperUnit">Unit:</label>
            <select id="paperUnit">
                <option value="px" selected>px</option>
                <option value="cm">cm</option>
                <option value="mm">mm</option>
                <option value="inch">inch</option>
            </select>
            <span id="paperScaleInfo" class="scale-info"></span>
        </div>
        <button id="setPaperSize">Apply</button>
    </div>
    <!-- Frame Settings -->
    <div>
        <h2>Frame Settings</h2>
        <div>
            <label for="frameName">Frame Name:</label>
            <input type="text" id="frameName" placeholder="Auto-generated if blank" />
        </div>
        <div>
            <label for="frameWidth">Width:</label>
            <input type="number" id="frameWidth" value="100" />
        </div>
        <div>
            <label for="frameHeight">Height:</label>
            <input type="number" id="frameHeight" value="100" />
        </div>
        <div>
            <label for="frameUnit">Unit:</label>
            <select id="frameUnit">
                <option value="px" selected>px</option>
                <option value="cm">cm</option>
                <option value="mm">mm</option>
                <option value="inch">inch</option>
            </select>
            <span id="frameScaleInfo" class="scale-info"></span>
        </div>
        <button id="addFrame">Add Frame</button>
        <button id="undoAction">Undo Last Frame</button>
    </div>
    <!-- Organize Section -->
    <div>
        <h2>Organize</h2>
        <div>
            <label for="marginInput">Margin:</label>
            <input type="number" id="marginInput" value="10" />
            <select id="marginUnit">
                <option value="px" selected>px</option>
                <option value="cm">cm</option>
                <option value="mm">mm</option>
                <option value="inch">inch</option>
            </select>
            <span id="marginScaleInfo" class="scale-info"></span>
        </div>
        <div>
            <label>
                <input type="checkbox" id="allowRotation" />
                Allow 90Â° rotations for optimal packing
            </label>
        </div>
        <button id="organizeBtn">Organize</button>
        <div id="paperSizeOutput"></div>
    </div>
</div>

<div id="paper" style="width:800px; height:600px;"></div>

<!-- Frame Tracker Section -->
<div id="frameTracker">
    <h2>Frame Tracker</h2>
    <button id="deleteAllFrames">Delete All Frames</button>
    <table>
        <thead>
        <tr>
            <th>ID</th>
            <th>Width</th>
            <th>Height</th>
            <th>Unit</th>
            <th>Rotation</th>
            <th>Actions</th>
        </tr>
        </thead>
        <tbody id="frameList">
        <!-- Frame rows will be added here -->
        </tbody>
    </table>
</div>

<script>
    // Conversion factors for scaling down from real size to screen size
    const conversionFactors = {
        px: 1,
        cm: 10,    // 1 cm = 10 px on screen
        mm: 1,     // 1 mm = 1 px on screen
        inch: 25   // 1 inch = 25 px on screen
    };

    // Update scale info displays for paper, frame, and margin units
    function updateScaleInfo() {
        const paperUnit = document.getElementById("paperUnit").value;
        const frameUnit = document.getElementById("frameUnit").value;
        document.getElementById("paperScaleInfo").textContent = `Scale: 1 ${paperUnit} = ${conversionFactors[paperUnit]} px`;
        document.getElementById("frameScaleInfo").textContent = `Scale: 1 ${frameUnit} = ${conversionFactors[frameUnit]} px`;
    }
    function updateMarginScaleInfo() {
        const marginUnit = document.getElementById("marginUnit").value;
        document.getElementById("marginScaleInfo").textContent = `Scale: 1 ${marginUnit} = ${conversionFactors[marginUnit]} px`;
    }
    updateScaleInfo();
    updateMarginScaleInfo();
    document.getElementById("paperUnit").addEventListener("change", updateScaleInfo);
    document.getElementById("frameUnit").addEventListener("change", updateScaleInfo);
    document.getElementById("marginUnit").addEventListener("change", updateMarginScaleInfo);

    const paper = document.getElementById("paper");
    const frameList = document.getElementById("frameList");
    let frameCount = 0;
    let frameHistory = []; // Stack for tracking frame insertions

    // Function to restrict input to numbers and at most one period.
    function allowOnlyNumbers(e) {
        // Allow control keys (backspace, tab, enter, etc.)
        if (e.ctrlKey || e.metaKey || e.altKey) return;
        // Allow navigation keys
        if (["ArrowLeft", "ArrowRight", "Backspace", "Delete"].indexOf(e.key) !== -1) return;
        const currentValue = e.target.textContent;
        // Allow digits
        if (!/[0-9]/.test(e.key)) {
            // Allow one dot if not already present
            if (e.key === "." && currentValue.indexOf(".") === -1) {
                return;
            }
            e.preventDefault();
        }
    }

    // Attach paste event to filter pasted text to numeric characters only.
    function filterPaste(e) {
        e.preventDefault();
        const text = (e.clipboardData || window.clipboardData).getData("text");
        const filtered = text.replace(/[^0-9.]/g, "");
        document.execCommand("insertText", false, filtered);
    }

    // Generate a unique ID given a base name
    function generateUniqueId(base) {
        let id = base;
        let counter = 1;
        while (document.getElementById(id)) {
            id = base + "-" + counter;
            counter++;
        }
        return id;
    }

    // Update all references for a frame when its ID is changed
    function updateFrameId(oldId, newId) {
        const frame = document.getElementById(oldId);
        if (frame) {
            frame.id = newId;
        }
        const row = document.getElementById(oldId + "-row");
        if (row) {
            row.id = newId + "-row";
            const deleteBtn = row.querySelector(".delete-btn");
            if (deleteBtn) {
                deleteBtn.setAttribute("data-frame-id", newId);
            }
            const slider = row.querySelector(".rotate-slider");
            if (slider) {
                slider.setAttribute("data-frame-id", newId);
            }
            const idCell = row.querySelector(".frame-id-cell");
            if (idCell) {
                idCell.setAttribute("data-frame-id", newId);
            }
        }
        const index = frameHistory.indexOf(oldId);
        if (index !== -1) {
            frameHistory[index] = newId;
        }
    }

    // Set paper size based on user input and chosen unit
    document.getElementById("setPaperSize").addEventListener("click", () => {
        const paperWidthInput = document.getElementById("paperWidth").value;
        const paperHeightInput = document.getElementById("paperHeight").value;
        const paperUnit = document.getElementById("paperUnit").value;
        const factor = conversionFactors[paperUnit];
        paper.style.width = paperWidthInput * factor + "px";
        paper.style.height = paperHeightInput * factor + "px";
    });

    // Add a new frame to the paper and update the tracker
    document.getElementById("addFrame").addEventListener("click", () => {
        const frameNameInput = document.getElementById("frameName").value.trim();
        const frameWidthInput = document.getElementById("frameWidth").value;
        const frameHeightInput = document.getElementById("frameHeight").value;
        const frameUnit = document.getElementById("frameUnit").value;
        const factor = conversionFactors[frameUnit];
        frameCount++;
        let baseName = frameNameInput ? frameNameInput : "frame-" + frameCount;
        let frameId = generateUniqueId(baseName);

        const frame = document.createElement("div");
        frame.classList.add("frame");
        frame.id = frameId;
        frame.style.width = frameWidthInput * factor + "px";
        frame.style.height = frameHeightInput * factor + "px";
        frame.style.left = "0px";
        frame.style.top = "0px";
        frame.style.transform = "rotate(0deg)";
        paper.appendChild(frame);
        makeDraggable(frame);
        frameHistory.push(frameId);

        const row = document.createElement("tr");
        row.id = frameId + "-row";
        row.innerHTML = `
      <td class="frame-id-cell" contenteditable="true" data-frame-id="${frameId}">${frameId}</td>
      <td class="dim-cell">${frameWidthInput}</td>
      <td class="dim-cell">${frameHeightInput}</td>
      <td>${frameUnit}</td>
      <td>
        <input type="range" min="0" max="360" value="0" data-frame-id="${frameId}" class="rotate-slider">
        <span class="rotate-value">0Â°</span>
      </td>
      <td><button class="delete-btn" data-frame-id="${frameId}">Delete</button></td>
    `;
        frameList.appendChild(row);

        const deleteBtn = row.querySelector(".delete-btn");
        deleteBtn.addEventListener("click", function () {
            const currentFrameId = this.getAttribute("data-frame-id");
            deleteFrame(currentFrameId);
        });

        const rotateSlider = row.querySelector(".rotate-slider");
        const rotateValue = row.querySelector(".rotate-value");
        rotateSlider.addEventListener("input", (e) => {
            const angle = e.target.value;
            frame.style.transform = `rotate(${angle}deg)`;
            rotateValue.textContent = `${angle}Â°`;
        });

        const idCell = row.querySelector(".frame-id-cell");
        idCell.addEventListener("blur", function (e) {
            const oldId = this.getAttribute("data-frame-id");
            const newIdCandidate = this.textContent.trim();
            if (newIdCandidate && newIdCandidate !== oldId) {
                const uniqueId = generateUniqueId(newIdCandidate);
                this.textContent = uniqueId;
                updateFrameId(oldId, uniqueId);
            } else if (!newIdCandidate) {
                this.textContent = oldId;
            }
        });

        // Make dimension cells editable and restrict input to numerical values.
        const widthCell = row.cells[1];
        const heightCell = row.cells[2];
        widthCell.contentEditable = "true";
        heightCell.contentEditable = "true";

        // Attach keypress and paste events to restrict input.
        widthCell.addEventListener("keypress", allowOnlyNumbers);
        heightCell.addEventListener("keypress", allowOnlyNumbers);
        widthCell.addEventListener("paste", filterPaste);
        heightCell.addEventListener("paste", filterPaste);

        widthCell.addEventListener("blur", function() {
            const newWidth = parseFloat(this.textContent);
            if (!isNaN(newWidth)) {
                const unit = row.cells[3].textContent;
                const factor = conversionFactors[unit];
                const newWidthPx = newWidth * factor;
                const frameElem = document.getElementById(row.id.replace("-row", ""));
                if (frameElem) {
                    frameElem.style.width = newWidthPx + "px";
                }
            } else {
                this.textContent = frameWidthInput;
            }
        });
        heightCell.addEventListener("blur", function() {
            const newHeight = parseFloat(this.textContent);
            if (!isNaN(newHeight)) {
                const unit = row.cells[3].textContent;
                const factor = conversionFactors[unit];
                const newHeightPx = newHeight * factor;
                const frameElem = document.getElementById(row.id.replace("-row", ""));
                if (frameElem) {
                    frameElem.style.height = newHeightPx + "px";
                }
            } else {
                this.textContent = frameHeightInput;
            }
        });
    });

    // Delete a specific frame and update history.
    function deleteFrame(frameId) {
        const frame = document.getElementById(frameId);
        if (frame) {
            paper.removeChild(frame);
        }
        const row = document.getElementById(frameId + "-row");
        if (row) {
            frameList.removeChild(row);
        }
        frameHistory = frameHistory.filter((id) => id !== frameId);
    }

    // Delete all frames and clear history.
    document.getElementById("deleteAllFrames").addEventListener("click", () => {
        while (paper.firstChild) {
            paper.removeChild(paper.firstChild);
        }
        frameList.innerHTML = "";
        frameHistory = [];
        frameCount = 0;
    });

    // Undo the last inserted frame.
    document.getElementById("undoAction").addEventListener("click", () => {
        if (frameHistory.length > 0) {
            const lastFrameId = frameHistory.pop();
            deleteFrame(lastFrameId);
        } else {
            alert("No actions to undo.");
        }
    });

    // Organize frames: arrange them with the specified margin and optionally allow 90Â° rotations.
    document.getElementById("organizeBtn").addEventListener("click", organizeFrames);

    function organizeFrames() {
        const marginInputVal = parseFloat(document.getElementById("marginInput").value) || 0;
        const marginUnit = document.getElementById("marginUnit").value;
        const margin = marginInputVal * conversionFactors[marginUnit];
        const allowRotation = document.getElementById("allowRotation").checked;

        const frameElements = Array.from(paper.getElementsByClassName("frame"));
        const frames = frameElements.map((frame) => {
            const width = parseInt(frame.style.width, 10);
            const height = parseInt(frame.style.height, 10);
            return { element: frame, origWidth: width, origHeight: height };
        });

        const totalArea = frames.reduce((sum, f) => sum + f.origWidth * f.origHeight, 0);
        let targetWidth = Math.ceil(Math.sqrt(totalArea)) + margin * 2;

        let currentX = margin;
        let currentY = margin;
        let rowHeight = 0;
        let maxX = 0;

        frames.forEach((f) => {
            let origW = f.origWidth,
                origH = f.origHeight;
            let usedW = origW,
                usedH = origH;
            let appliedRotation = 0;

            if (allowRotation) {
                const normalFits = currentX + origW + margin <= targetWidth;
                const rotatedFits = currentX + origH + margin <= targetWidth;
                if (!normalFits && rotatedFits) {
                    usedW = origH;
                    usedH = origW;
                    appliedRotation = 90;
                } else if (normalFits && rotatedFits) {
                    const option1RowHeight = Math.max(rowHeight, origH);
                    const option2RowHeight = Math.max(rowHeight, origW);
                    if (option2RowHeight < option1RowHeight) {
                        usedW = origH;
                        usedH = origW;
                        appliedRotation = 90;
                    }
                }
            }

            if (currentX + usedW + margin > targetWidth) {
                currentY += rowHeight + margin;
                currentX = margin;
                rowHeight = 0;
            }

            f.element.style.left = currentX + "px";
            f.element.style.top = currentY + "px";
            if (appliedRotation) {
                f.element.style.transform = `rotate(${appliedRotation}deg)`;
                f.element.style.width = usedW + "px";
                f.element.style.height = usedH + "px";
                const row = document.getElementById(f.element.id + "-row");
                if (row) {
                    row.cells[1].textContent = usedW;
                    row.cells[2].textContent = usedH;
                }
            } else {
                f.element.style.transform = "rotate(0deg)";
            }
            currentX += usedW + margin;
            rowHeight = Math.max(rowHeight, usedH);
            maxX = Math.max(maxX, currentX);
        });

        const newPaperWidth = maxX;
        const newPaperHeight = currentY + rowHeight + margin;
        paper.style.width = newPaperWidth + "px";
        paper.style.height = newPaperHeight + "px";

        const paperSizeOutput = document.getElementById("paperSizeOutput");
        paperSizeOutput.textContent = `Paper Size: ${newPaperWidth}px x ${newPaperHeight}px`;
    }

    // Basic drag functionality with boundary constraints.
    function makeDraggable(element) {
        let initialX, initialY;
        element.addEventListener("mousedown", dragStart);
        document.addEventListener("mouseup", dragEnd);
        document.addEventListener("mousemove", drag);

        function dragStart(e) {
            initialX = e.clientX - parseInt(element.style.left, 10);
            initialY = e.clientY - parseInt(element.style.top, 10);
            element.classList.add("dragging");
            element.style.zIndex = 1000;
        }

        function drag(e) {
            if (element.classList.contains("dragging")) {
                let newX = e.clientX - initialX;
                let newY = e.clientY - initialY;
                const parentWidth = paper.clientWidth;
                const parentHeight = paper.clientHeight;
                const frameWidth = element.offsetWidth;
                const frameHeight = element.offsetHeight;
                newX = Math.max(0, Math.min(newX, parentWidth - frameWidth));
                newY = Math.max(0, Math.min(newY, parentHeight - frameHeight));
                element.style.left = newX + "px";
                element.style.top = newY + "px";
            }
        }

        function dragEnd() {
            element.classList.remove("dragging");
            element.style.zIndex = "";
        }
    }
</script>
</body>
</html>

















