<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Paper Layout Organizer</title>
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700" rel="stylesheet" />
    <style>
        :root {
            --primary-color: #007bff;
            --background-color: #f7f9fc;
            --paper-background: #ffffff;
            --frame-background: rgba(0, 123, 255, 0.1);
            --text-color: #333;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background: var(--background-color);
            margin: 0;
            padding: 20px;
            color: var(--text-color);
        }
        h2 {
            margin: 0 0 10px;
        }
        #controls {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 40px;
            align-items: flex-start;
        }
        #controls > div {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        label {
            font-weight: 500;
            margin-right: 5px;
        }
        input[type="number"],
        input[type="text"],
        select {
            padding: 6px 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100px;
        }
        input[type="text"] {
            width: 150px;
        }
        button {
            padding: 8px 15px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            background: var(--primary-color);
            color: #fff;
            cursor: pointer;
            transition: background 0.3s ease;
            align-self: flex-start;
        }
        button:hover {
            background: #0056b3;
        }
        #paper {
            position: relative;
            margin: 0 auto 20px auto;
            background: var(--paper-background);
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        /* Use center as transform origin for drag but note that for organize we assume top-left.
           (You might adjust this as needed.) */
        .frame {
            position: absolute;
            border: 2px solid var(--primary-color);
            background: var(--frame-background);
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            box-sizing: border-box;
            cursor: move;
            transition: box-shadow 0.2s ease;
            transform-origin: center;
        }
        .frame.dragging {
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        /* Frame Tracker styling */
        #frameTracker {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        #frameTracker table {
            width: 100%;
            border-collapse: collapse;
        }
        #frameTracker th,
        #frameTracker td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        #frameTracker th {
            background-color: #f0f0f0;
        }
        .frame-id-cell {
            cursor: text;
        }
        .dim-cell {
            cursor: text;
        }
        .delete-btn {
            background: #dc3545;
            border: none;
            border-radius: 4px;
            color: #fff;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }
        .delete-btn:hover {
            background: #c82333;
        }
        #deleteAllFrames,
        #undoAction {
            margin-bottom: 10px;
            background: #dc3545;
        }
        #undoAction {
            background: #6c757d;
        }
        #undoAction:hover {
            background: #5a6268;
        }
        .scale-info {
            font-size: 12px;
            color: #555;
            margin-left: 5px;
        }
        .rotate-slider {
            width: 100px;
        }
        .rotate-value {
            font-size: 12px;
            margin-left: 5px;
        }
        #paperSizeOutput {
            margin-top: 10px;
            font-size: 14px;
            color: #333;
            border: 1px solid #ccc;
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
            background: #fff;
        }
    </style>
</head>
<body>

<div id="controls">
    <!-- Paper Settings -->
    <div>
        <h2>Paper Settings</h2>
        <div>
            <label for="paperWidth">Width:</label>
            <input type="number" id="paperWidth" value="32" />
        </div>
        <div>
            <label for="paperHeight">Height:</label>
            <input type="number" id="paperHeight" value="24" />
        </div>
        <div>
            <label for="paperUnit">Unit:</label>
            <select id="paperUnit">
                <option value="px" >px</option>
                <option value="cm">cm</option>
                <option value="mm">mm</option>
                <option value="inch" selected>inch</option>
            </select>
            <span id="paperScaleInfo" class="scale-info"></span>
        </div>
        <button id="setPaperSize">Apply</button>
    </div>
    <!-- Frame Settings -->
    <div>
        <h2>Frame Settings</h2>
        <div>
            <label for="frameName">Frame Name:</label>
            <input type="text" id="frameName" placeholder="Auto-generated if blank" />
        </div>
        <div>
            <label for="frameWidth">Width:</label>
            <input type="number" id="frameWidth" value="10" />
        </div>
        <div>
            <label for="frameHeight">Height:</label>
            <input type="number" id="frameHeight" value="5" />
        </div>
        <div>
            <label for="frameUnit">Unit:</label>
            <select id="frameUnit">
                <option value="px" >px</option>
                <option value="cm">cm</option>
                <option value="mm">mm</option>
                <option value="inch" selected>inch</option>
            </select>
            <span id="frameScaleInfo" class="scale-info"></span>
        </div>
        <button id="addFrame">Add Frame</button>
        <button id="undoAction">Undo Last Frame</button>
    </div>
    <!-- Organize Section -->
    <div>
        <h2>Organize</h2>
        <div>
            <label for="marginInput">Margin:</label>
            <input type="number" id="marginInput" value="10" />
            <select id="marginUnit">
                <option value="px" >px</option>
                <option value="cm">cm</option>
                <option value="mm">mm</option>
                <option value="inch" selected>inch</option>
            </select>
            <span id="marginScaleInfo" class="scale-info"></span>
        </div>
        <div>
            <label>
                <input type="checkbox" id="allowRotation" />
                Allow 90° rotations for optimal packing
            </label>
        </div>
        <button id="organizeBtn">Organize</button>
        <div id="paperSizeOutput"></div>
    </div>
</div>

<div id="paper" style="width:800px; height:600px;"></div>

<!-- Frame Tracker Section -->
<div id="frameTracker">
    <h2>Frame Tracker</h2>
    <button id="deleteAllFrames">Delete All Frames</button>
    <table>
        <thead>
        <tr>
            <th>ID</th>
            <th>Width</th>
            <th>Height</th>
            <th>Unit</th>
            <th>Rotation</th>
            <th>Actions</th>
        </tr>
        </thead>
        <tbody id="frameList">
        <!-- Frame rows will be added here -->
        </tbody>
    </table>
</div>

<script>
    // Global current unit state; initially "px"
    let currentUnit = "inch";

    const conversionFactors = {
        px: 1,
        cm: 10,
        mm: 1,
        inch: 25
    };

    // Functions to update scale info displays.
    function updateScaleInfo() {
        document.getElementById("paperScaleInfo").textContent = `Scale: 1 ${currentUnit} = ${conversionFactors[currentUnit]} px`;
        document.getElementById("frameScaleInfo").textContent = `Scale: 1 ${currentUnit} = ${conversionFactors[currentUnit]} px`;
    }
    function updateMarginScaleInfo() {
        document.getElementById("marginScaleInfo").textContent = `Scale: 1 ${currentUnit} = ${conversionFactors[currentUnit]} px`;
    }
    updateScaleInfo();
    updateMarginScaleInfo();

    // Sync unit change across all unit selectors and convert dimensions.
    function syncUnits(newUnit) {
        if (newUnit === currentUnit) return;
        const oldUnit = currentUnit;
        currentUnit = newUnit;
        // Conversion ratio from old unit to new unit.
        const ratio = conversionFactors[oldUnit] / conversionFactors[newUnit];

        // Update paper dimensions.
        const paperWidthInput = document.getElementById("paperWidth");
        const paperHeightInput = document.getElementById("paperHeight");
        const oldPaperWidth = parseFloat(paperWidthInput.value);
        const oldPaperHeight = parseFloat(paperHeightInput.value);
        const actualPaperWidthPx = oldPaperWidth * conversionFactors[oldUnit];
        const actualPaperHeightPx = oldPaperHeight * conversionFactors[oldUnit];
        const newPaperWidthValue = actualPaperWidthPx / conversionFactors[newUnit];
        const newPaperHeightValue = actualPaperHeightPx / conversionFactors[newUnit];
        paperWidthInput.value = newPaperWidthValue;
        paperHeightInput.value = newPaperHeightValue;
        // Paper element remains in px.
        paper.style.width = actualPaperWidthPx + "px";
        paper.style.height = actualPaperHeightPx + "px";

        // Update frame tracker dimensions.
        const rows = document.querySelectorAll("#frameList tr");
        rows.forEach(row => {
            const unitCell = row.cells[3];
            // Change unit cell to new unit.
            unitCell.textContent = newUnit;
            // For width and height, recalc based on stored original pixel dimensions.
            const frameId = row.id.replace("-row", "");
            const frameElem = document.getElementById(frameId);
            if (frameElem) {
                const origWidthPx = parseFloat(frameElem.dataset.origWidth);
                const origHeightPx = parseFloat(frameElem.dataset.origHeight);
                const newWidthDisplayed = origWidthPx / conversionFactors[newUnit];
                const newHeightDisplayed = origHeightPx / conversionFactors[newUnit];
                row.cells[1].textContent = newWidthDisplayed;
                row.cells[2].textContent = newHeightDisplayed;
            }
        });

        // Update margin input.
        const marginInput = document.getElementById("marginInput");
        const oldMargin = parseFloat(marginInput.value);
        marginInput.value = oldMargin * ratio; // multiply by ratio to convert
        // Update all unit selectors to newUnit.
        document.getElementById("paperUnit").value = newUnit;
        document.getElementById("frameUnit").value = newUnit;
        document.getElementById("marginUnit").value = newUnit;
        updateScaleInfo();
        updateMarginScaleInfo();
    }

    // Attach event listeners to unit selectors.
    document.getElementById("paperUnit").addEventListener("change", function() {
        syncUnits(this.value);
    });
    document.getElementById("frameUnit").addEventListener("change", function() {
        syncUnits(this.value);
    });
    document.getElementById("marginUnit").addEventListener("change", function() {
        syncUnits(this.value);
    });

    const paper = document.getElementById("paper");
    const frameList = document.getElementById("frameList");
    let frameCount = 0;
    let frameHistory = [];

    // Store original dimensions in data attributes.
    function addFrameDataAttributes(frame, widthPx, heightPx) {
        frame.dataset.origWidth = widthPx;
        frame.dataset.origHeight = heightPx;
    }

    function generateUniqueId(base) {
        let id = base;
        let counter = 1;
        while (document.getElementById(id)) {
            id = base + "-" + counter;
            counter++;
        }
        return id;
    }

    function updateFrameId(oldId, newId) {
        const frame = document.getElementById(oldId);
        if (frame) frame.id = newId;
        const row = document.getElementById(oldId + "-row");
        if (row) {
            row.id = newId + "-row";
            const deleteBtn = row.querySelector(".delete-btn");
            if (deleteBtn) deleteBtn.setAttribute("data-frame-id", newId);
            const slider = row.querySelector(".rotate-slider");
            if (slider) slider.setAttribute("data-frame-id", newId);
            const idCell = row.querySelector(".frame-id-cell");
            if (idCell) idCell.setAttribute("data-frame-id", newId);
        }
        const index = frameHistory.indexOf(oldId);
        if (index !== -1) frameHistory[index] = newId;
    }

    document.getElementById("setPaperSize").addEventListener("click", () => {
        const paperWidthInput = document.getElementById("paperWidth").value;
        const paperHeightInput = document.getElementById("paperHeight").value;
        // Actual dimensions in pixels remain the same.
        const actualWidthPx = paperWidthInput * conversionFactors[currentUnit];
        const actualHeightPx = paperHeightInput * conversionFactors[currentUnit];
        paper.style.width = actualWidthPx + "px";
        paper.style.height = actualHeightPx + "px";
    });

    document.getElementById("addFrame").addEventListener("click", () => {
        const frameNameInput = document.getElementById("frameName").value.trim();
        const frameWidthInput = document.getElementById("frameWidth").value;
        const frameHeightInput = document.getElementById("frameHeight").value;
        // Use currentUnit for frame dimensions.
        const factor = conversionFactors[currentUnit];
        frameCount++;
        let baseName = frameNameInput ? frameNameInput : "frame-" + frameCount;
        let frameId = generateUniqueId(baseName);

        const widthPx = frameWidthInput * factor;
        const heightPx = frameHeightInput * factor;

        const frame = document.createElement("div");
        frame.classList.add("frame");
        frame.id = frameId;
        frame.style.width = widthPx + "px";
        frame.style.height = heightPx + "px";
        frame.style.left = "0px";
        frame.style.top = "0px";
        frame.style.transform = "rotate(0deg)";
        paper.appendChild(frame);
        addFrameDataAttributes(frame, widthPx, heightPx);
        makeDraggable(frame);
        frameHistory.push(frameId);

        const row = document.createElement("tr");
        row.id = frameId + "-row";
        row.innerHTML = `
      <td class="frame-id-cell" contenteditable="true" data-frame-id="${frameId}">${frameId}</td>
      <td class="dim-cell">${frameWidthInput}</td>
      <td class="dim-cell">${frameHeightInput}</td>
      <td>${currentUnit}</td>
      <td>
        <input type="range" min="0" max="360" value="0" data-frame-id="${frameId}" class="rotate-slider">
        <span class="rotate-value">0°</span>
      </td>
      <td><button class="delete-btn" data-frame-id="${frameId}">Delete</button></td>
    `;
        frameList.appendChild(row);

        const deleteBtn = row.querySelector(".delete-btn");
        deleteBtn.addEventListener("click", function () {
            const currentFrameId = this.getAttribute("data-frame-id");
            deleteFrame(currentFrameId);
        });

        const rotateSlider = row.querySelector(".rotate-slider");
        const rotateValue = row.querySelector(".rotate-value");
        rotateSlider.addEventListener("input", (e) => {
            const angle = e.target.value;
            frame.style.transform = `rotate(${angle}deg)`;
            rotateValue.textContent = `${angle}°`;
        });

        const idCell = row.querySelector(".frame-id-cell");
        idCell.addEventListener("blur", function () {
            const oldId = this.getAttribute("data-frame-id");
            const newIdCandidate = this.textContent.trim();
            if (newIdCandidate && newIdCandidate !== oldId) {
                const uniqueId = generateUniqueId(newIdCandidate);
                this.textContent = uniqueId;
                updateFrameId(oldId, uniqueId);
            } else if (!newIdCandidate) {
                this.textContent = oldId;
            }
        });

        const widthCell = row.cells[1];
        const heightCell = row.cells[2];
        widthCell.contentEditable = "true";
        heightCell.contentEditable = "true";
        widthCell.addEventListener("keypress", allowOnlyNumbers);
        heightCell.addEventListener("keypress", allowOnlyNumbers);
        widthCell.addEventListener("paste", filterPaste);
        heightCell.addEventListener("paste", filterPaste);
        widthCell.addEventListener("blur", function() {
            const newWidth = parseFloat(this.textContent);
            if (!isNaN(newWidth)) {
                const newWidthPx = newWidth * conversionFactors[currentUnit];
                const frameElem = document.getElementById(row.id.replace("-row", ""));
                if (frameElem) {
                    frameElem.style.width = newWidthPx + "px";
                    frameElem.dataset.origWidth = newWidthPx;
                }
            } else {
                this.textContent = frameWidthInput;
            }
        });
        heightCell.addEventListener("blur", function() {
            const newHeight = parseFloat(this.textContent);
            if (!isNaN(newHeight)) {
                const newHeightPx = newHeight * conversionFactors[currentUnit];
                const frameElem = document.getElementById(row.id.replace("-row", ""));
                if (frameElem) {
                    frameElem.style.height = newHeightPx + "px";
                    frameElem.dataset.origHeight = newHeightPx;
                }
            } else {
                this.textContent = frameHeightInput;
            }
        });
    });

    function allowOnlyNumbers(e) {
        if (e.ctrlKey || e.metaKey || e.altKey) return;
        if (["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(e.key)) return;
        const currentValue = e.target.textContent;
        if (!/[0-9]/.test(e.key)) {
            if (e.key === "." && currentValue.indexOf(".") === -1) return;
            e.preventDefault();
        }
    }
    function filterPaste(e) {
        e.preventDefault();
        const text = (e.clipboardData || window.clipboardData).getData("text");
        const filtered = text.replace(/[^0-9.]/g, "");
        document.execCommand("insertText", false, filtered);
    }

    function deleteFrame(frameId) {
        const frame = document.getElementById(frameId);
        if (frame) paper.removeChild(frame);
        const row = document.getElementById(frameId + "-row");
        if (row) frameList.removeChild(row);
        frameHistory = frameHistory.filter(id => id !== frameId);
    }

    document.getElementById("deleteAllFrames").addEventListener("click", () => {
        while (paper.firstChild) paper.removeChild(paper.firstChild);
        frameList.innerHTML = "";
        frameHistory = [];
        frameCount = 0;
    });

    document.getElementById("undoAction").addEventListener("click", () => {
        if (frameHistory.length > 0) {
            const lastFrameId = frameHistory.pop();
            deleteFrame(lastFrameId);
        } else {
            alert("No actions to undo.");
        }
    });

    document.getElementById("organizeBtn").addEventListener("click", organizeFrames);

    function organizeFrames() {
        const marginInputVal = parseFloat(document.getElementById("marginInput").value) || 0;
        const margin = marginInputVal * conversionFactors[currentUnit];
        const allowRotation = document.getElementById("allowRotation").checked;

        const frameElements = Array.from(paper.getElementsByClassName("frame"));
        const frames = frameElements.map(frame => {
            const origW = parseFloat(frame.dataset.origWidth);
            const origH = parseFloat(frame.dataset.origHeight);
            return { element: frame, origWidth: origW, origHeight: origH };
        });

        const totalArea = frames.reduce((sum, f) => sum + f.origWidth * f.origHeight, 0);
        let targetWidth = Math.ceil(Math.sqrt(totalArea)) + margin * 2;

        let currentX = margin;
        let currentY = margin;
        let rowHeight = 0;
        let maxX = 0;

        frames.forEach(f => {
            let origW = f.origWidth, origH = f.origHeight;
            let usedW = origW, usedH = origH;
            let appliedRotation = 0;

            if (allowRotation) {
                const normalFits = currentX + origW + margin <= targetWidth;
                const rotatedFits = currentX + origH + margin <= targetWidth;
                if (!normalFits && rotatedFits) {
                    usedW = origH;
                    usedH = origW;
                    appliedRotation = 90;
                } else if (normalFits && rotatedFits) {
                    const option1RowHeight = Math.max(rowHeight, origH);
                    const option2RowHeight = Math.max(rowHeight, origW);
                    if (option2RowHeight < option1RowHeight) {
                        usedW = origH;
                        usedH = origW;
                        appliedRotation = 90;
                    }
                }
            }

            if (currentX + usedW + margin > targetWidth) {
                currentY += rowHeight + margin;
                currentX = margin;
                rowHeight = 0;
            }

            f.element.style.left = currentX + "px";
            f.element.style.top = currentY + "px";
            if (appliedRotation) {
                f.element.style.transform = `rotate(${appliedRotation}deg)`;
                f.element.style.width = usedW + "px";
                f.element.style.height = usedH + "px";
                const row = document.getElementById(f.element.id + "-row");
                if (row) {
                    row.cells[1].textContent = usedW;
                    row.cells[2].textContent = usedH;
                }
            } else {
                f.element.style.transform = "rotate(0deg)";
            }
            currentX += usedW + margin;
            rowHeight = Math.max(rowHeight, usedH);
            maxX = Math.max(maxX, currentX);
        });

        const newPaperWidth = maxX;
        const newPaperHeight = currentY + rowHeight + margin;
        paper.style.width = newPaperWidth + "px";
        paper.style.height = newPaperHeight + "px";

        const paperSizeOutput = document.getElementById("paperSizeOutput");
        const displayedWidth = newPaperWidth / conversionFactors[currentUnit];
        const displayedHeight = newPaperHeight / conversionFactors[currentUnit];
        paperSizeOutput.textContent = `Paper Size: ${displayedWidth.toFixed(2)} ${currentUnit} x ${displayedHeight.toFixed(2)} ${currentUnit}`;
    }

    function makeDraggable(element) {
        let initialX, initialY;
        element.addEventListener("mousedown", dragStart);
        document.addEventListener("mouseup", dragEnd);
        document.addEventListener("mousemove", drag);

        function dragStart(e) {
            initialX = e.clientX - parseInt(element.style.left, 10);
            initialY = e.clientY - parseInt(element.style.top, 10);
            element.classList.add("dragging");
            element.style.zIndex = 1000;
        }

        function drag(e) {
            if (element.classList.contains("dragging")) {
                let newX = e.clientX - initialX;
                let newY = e.clientY - initialY;
                const parentWidth = paper.clientWidth;
                const parentHeight = paper.clientHeight;
                const frameWidth = element.offsetWidth;
                const frameHeight = element.offsetHeight;
                newX = Math.max(0, Math.min(newX, parentWidth - frameWidth));
                newY = Math.max(0, Math.min(newY, parentHeight - frameHeight));
                element.style.left = newX + "px";
                element.style.top = newY + "px";
            }
        }

        function dragEnd() {
            element.classList.remove("dragging");
            element.style.zIndex = "";
        }
    }
</script>
</body>
</html>
