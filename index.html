<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Paper Layout Organizer</title>
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700" rel="stylesheet" />
    <style>
        :root {
            --primary-color: #007bff;
            --background-color: #f7f9fc;
            --paper-background: #ffffff;
            --frame-background: rgba(0, 123, 255, 0.1);
            --text-color: #333;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background: var(--background-color);
            margin: 0;
            padding: 20px;
            color: var(--text-color);
        }
        h2 {
            margin: 0 0 10px;
        }
        #controls {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 40px;
            align-items: flex-start;
        }
        #controls > div {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        label {
            font-weight: 500;
            margin-right: 5px;
        }
        input[type="number"],
        input[type="text"],
        select {
            padding: 6px 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100px;
        }
        input[type="text"] {
            width: 150px;
        }
        button {
            padding: 8px 15px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            background: var(--primary-color);
            color: #fff;
            cursor: pointer;
            transition: background 0.3s ease;
            align-self: flex-start;
        }
        button:hover {
            background: #0056b3;
        }
        #paper {
            position: relative;
            margin: 0 auto 20px auto;
            background: var(--paper-background);
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            overflow: hidden;
        }
        /* Use center as transform origin for drag but note that for organize we assume top-left.
           (You might adjust this as needed.) */
        .frame {
            position: absolute;
            border: 2px solid var(--primary-color);
            background: var(--frame-background);
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            box-sizing: border-box;
            cursor: move;
            transition: box-shadow 0.2s ease;
            transform-origin: center;
        }
        .frame.dragging {
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        /* Frame Tracker styling */
        #frameTracker {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        #frameTracker table {
            background: #edf7f7;
            width: 100%;
            border-collapse: collapse;
        }
        #frameTracker th,
        #frameTracker td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        #frameTracker th {
            background-color: #f0f0f0;
        }
        .frame-id-cell {
            cursor: text;
        }
        .dim-cell {
            cursor: text;
        }
        .delete-btn {
            background: #dc3545;
            border: none;
            border-radius: 4px;
            color: #fff;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }
        .delete-btn:hover {
            background: #c82333;
        }
        #deleteAllFrames,
        #undoAction {
            margin-bottom: 10px;
            background: #dc3545;
        }
        #undoAction {
            background: #6c757d;
        }
        #undoAction:hover {
            background: #5a6268;
        }
        .scale-info {
            font-size: 12px;
            color: #555;
            margin-left: 5px;
        }
        .rotate-slider {
            width: 100px;
        }
        .rotate-value {
            font-size: 12px;
            margin-left: 5px;
        }
        #paperSizeOutput {
            margin-top: 10px;
            font-size: 14px;
            color: #333;
            border: 1px solid #ccc;
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
            background: #edf7f7;
        }

        /* Styles for frame size display */
        .frame-size-display {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(255, 255, 255, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            color: #333;
            pointer-events: none; /* Make sure it doesn't interfere with dragging */
            white-space: nowrap;
            z-index: 5;
        }

        /* Toggle button for showing/hiding measurements */
        #toggleFrameSizes {
            margin-left: 10px;
            background: #6c757d;
        }
        #toggleFrameSizes:hover {
            background: #5a6268;
        }

    </style>
</head>
<body>

<div id="controls">
    <!-- Paper Settings -->
    <div>
        <h2>Paper Settings</h2>
        <h3 style="font-size:14px;">(use only for viewing purposes)</h3>
        <div>
            <label for="paperWidth">Width:</label>
            <input type="number" id="paperWidth" value="32" min="0"/>
        </div>
        <div>
            <label for="paperHeight">Height:</label>
            <input type="number" id="paperHeight" value="24" min="0"/>
        </div>
        <div>
            <label for="paperUnit">Unit:</label>
            <select id="paperUnit">
                <option value="px" >px</option>
                <option value="cm">cm</option>
                <option value="mm">mm</option>
                <option value="inch" selected>inch</option>
            </select>
            <span id="paperScaleInfo" class="scale-info"></span>
        </div>
        <button id="setPaperSize">Apply</button>
    </div>
    <!-- Frame Settings -->
    <div>
        <h2>Frame Settings</h2>
        <div>
            <label for="frameName">Frame Name:</label>
            <input type="text" id="frameName" placeholder="Auto-generated if blank" />
        </div>
        <div>
            <label for="frameWidth">Width:</label>
            <input type="number" id="frameWidth" value="10" min="0"/>
        </div>
        <div>
            <label for="frameHeight">Height:</label>
            <input type="number" id="frameHeight" value="5" min="0"/>
        </div>
        <div>
            <label for="frameUnit">Unit:</label>
            <select id="frameUnit">
                <option value="px" >px</option>
                <option value="cm">cm</option>
                <option value="mm">mm</option>
                <option value="inch" selected>inch</option>
            </select>
            <span id="frameScaleInfo" class="scale-info"></span>
        </div>
        <button id="addFrame">Add Frame</button>
        <button id="undoAction">Undo Last Frame</button>
    </div>
    <!-- Organize Section -->
    <div>
        <h2>Organize</h2>
        <div>
            <label for="marginInput">Margin:</label>
            <input type="number" id="marginInput" value="1" min="0"/>
            <select id="marginUnit">
                <option value="px" >px</option>
                <option value="cm">cm</option>
                <option value="mm">mm</option>
                <option value="inch" selected>inch</option>
            </select>
            <span id="marginScaleInfo" class="scale-info"></span>
        </div>
        <div>
            <label>
                <input type="checkbox" id="allowRotation" />
                Allow 90° rotations for optimal packing
            </label>
        </div>
        <button id="organizeBtn">Organize</button>
        <button id="toggleFrameSizes">Show/Hide Sizes</button>
        <div id="paperSizeOutput"></div>
    </div>
</div>

<div id="paper" style="width:800px; height:600px;"></div>

<!-- Frame Tracker Section -->
<div id="frameTracker">
    <h2>Frame Tracker</h2>
    <button id="deleteAllFrames">Delete All Frames</button>
    <table>
        <thead>
        <tr>
            <th>ID</th>
            <th>Width</th>
            <th>Height</th>
            <th>Unit</th>
            <th>Rotation</th>
            <th>Actions</th>
        </tr>
        </thead>
        <tbody id="frameList">
        <!-- Frame rows will be added here -->
        </tbody>
    </table>
</div>

<script>
    // Global current unit state; initially "inch"
    let currentUnit = "inch";

    const conversionFactors = {
        px: 1,
        cm: 10,
        mm: 1,
        inch: 25
    };

    // Functions to update scale info displays.
    function updateScaleInfo() {
        document.getElementById("paperScaleInfo").textContent = `Scale: 1 ${currentUnit} = ${conversionFactors[currentUnit]} px`;
        document.getElementById("frameScaleInfo").textContent = `Scale: 1 ${currentUnit} = ${conversionFactors[currentUnit]} px`;
    }
    function updateMarginScaleInfo() {
        document.getElementById("marginScaleInfo").textContent = `Scale: 1 ${currentUnit} = ${conversionFactors[currentUnit]} px`;
    }
    updateScaleInfo();
    updateMarginScaleInfo();

    function syncUnits(newUnit) {
        if (newUnit === currentUnit) return;
        const oldUnit = currentUnit;
        currentUnit = newUnit;
        // Conversion ratio from old unit to new unit.
        const ratio = conversionFactors[oldUnit] / conversionFactors[newUnit];

        // Update paper dimensions.
        const paperWidthInput = document.getElementById("paperWidth");
        const paperHeightInput = document.getElementById("paperHeight");
        const oldPaperWidth = parseFloat(paperWidthInput.value);
        const oldPaperHeight = parseFloat(paperHeightInput.value);
        const actualPaperWidthPx = oldPaperWidth * conversionFactors[oldUnit];
        const actualPaperHeightPx = oldPaperHeight * conversionFactors[oldUnit];
        const newPaperWidthValue = actualPaperWidthPx / conversionFactors[newUnit];
        const newPaperHeightValue = actualPaperHeightPx / conversionFactors[newUnit];
        paperWidthInput.value = newPaperWidthValue;
        paperHeightInput.value = newPaperHeightValue;
        paper.style.width = actualPaperWidthPx + "px";
        paper.style.height = actualPaperHeightPx + "px";

        // Update frame tracker dimensions.
        const rows = document.querySelectorAll("#frameList tr");
        rows.forEach(row => {
            const unitCell = row.cells[3];
            unitCell.textContent = newUnit;
            const frameId = row.id.replace("-row", "");
            const frameElem = document.getElementById(frameId);
            if (frameElem) {
                const origWidthPx = parseFloat(frameElem.dataset.origWidth);
                const origHeightPx = parseFloat(frameElem.dataset.origHeight);
                const newWidthDisplayed = origWidthPx / conversionFactors[newUnit];
                const newHeightDisplayed = origHeightPx / conversionFactors[newUnit];
                row.cells[1].textContent = newWidthDisplayed;
                row.cells[2].textContent = newHeightDisplayed;
            }
        });

        // Update margin input.
        const marginInput = document.getElementById("marginInput");
        const oldMargin = parseFloat(marginInput.value);
        marginInput.value = oldMargin * ratio; // multiply by ratio to convert
        document.getElementById("paperUnit").value = newUnit;
        document.getElementById("frameUnit").value = newUnit;
        document.getElementById("marginUnit").value = newUnit;
        updateScaleInfo();
        updateMarginScaleInfo();
        updateAllFrameSizeDisplays();
    }

    document.getElementById("paperUnit").addEventListener("change", function() {
        syncUnits(this.value);
    });
    document.getElementById("frameUnit").addEventListener("change", function() {
        syncUnits(this.value);
    });
    document.getElementById("marginUnit").addEventListener("change", function() {
        syncUnits(this.value);
    });

    const paper = document.getElementById("paper");
    const frameList = document.getElementById("frameList");
    let frameCount = 0;
    let frameHistory = [];

    function addFrameDataAttributes(frame, widthPx, heightPx) {
        frame.dataset.origWidth = widthPx;
        frame.dataset.origHeight = heightPx;
    }

    function generateUniqueId(base) {
        let id = base;
        let counter = 1;
        while (document.getElementById(id)) {
            id = base + "-" + counter;
            counter++;
        }
        return id;
    }

    function updateFrameId(oldId, newId) {
        const frame = document.getElementById(oldId);
        if (frame) frame.id = newId;
        const row = document.getElementById(oldId + "-row");
        if (row) {
            row.id = newId + "-row";
            const deleteBtn = row.querySelector(".delete-btn");
            if (deleteBtn) {
                deleteBtn.setAttribute("data-frame-id", newId);
            }
            const slider = row.querySelector(".rotate-slider");
            if (slider) {
                slider.setAttribute("data-frame-id", newId);
            }
            const idCell = row.querySelector(".frame-id-cell");
            if (idCell) {
                idCell.setAttribute("data-frame-id", newId);
            }
        }
        const index = frameHistory.indexOf(oldId);
        if (index !== -1) {
            frameHistory[index] = newId;
        }
    }

    document.getElementById("setPaperSize").addEventListener("click", () => {
        const paperWidthInput = document.getElementById("paperWidth").value;
        const paperHeightInput = document.getElementById("paperHeight").value;
        const actualWidthPx = paperWidthInput * conversionFactors[currentUnit];
        const actualHeightPx = paperHeightInput * conversionFactors[currentUnit];
        paper.style.width = actualWidthPx + "px";
        paper.style.height = actualHeightPx + "px";
    });

    document.getElementById("addFrame").addEventListener("click", () => {
        const frameNameInput = document.getElementById("frameName").value.trim();
        const frameWidthInput = document.getElementById("frameWidth").value;
        const frameHeightInput = document.getElementById("frameHeight").value;
        const factor = conversionFactors[currentUnit];
        frameCount++;
        let baseName = frameNameInput ? frameNameInput : "frame-" + frameCount;
        let frameId = generateUniqueId(baseName);

        const widthPx = frameWidthInput * factor;
        const heightPx = frameHeightInput * factor;

        const frame = document.createElement("div");
        frame.classList.add("frame");
        frame.id = frameId;
        frame.style.width = widthPx + "px";
        frame.style.height = heightPx + "px";
        frame.style.left = "0px";
        frame.style.top = "0px";
        frame.style.transform = "rotate(0deg)";
        paper.appendChild(frame);
        addFrameDataAttributes(frame, widthPx, heightPx);
        makeDraggable(frame);
        frameHistory.push(frameId);

        const row = document.createElement("tr");
        row.id = frameId + "-row";
        row.innerHTML = `
      <td class="frame-id-cell" contenteditable="true" data-frame-id="${frameId}">${frameId}</td>
      <td class="dim-cell">${frameWidthInput}</td>
      <td class="dim-cell">${frameHeightInput}</td>
      <td>${currentUnit}</td>
      <td>
        <input type="range" min="0" max="360" value="0" data-frame-id="${frameId}" class="rotate-slider">
        <span class="rotate-value">0°</span>
      </td>
      <td><button class="delete-btn" data-frame-id="${frameId}">Delete</button></td>
    `;
        frameList.appendChild(row);

        const deleteBtn = row.querySelector(".delete-btn");
        deleteBtn.addEventListener("click", function () {
            const currentFrameId = this.getAttribute("data-frame-id");
            deleteFrame(currentFrameId);
        });

        const rotateSlider = row.querySelector(".rotate-slider");
        const rotateValue = row.querySelector(".rotate-value");
        rotateSlider.addEventListener("input", (e) => {
            const angle = e.target.value;
            frame.style.transform = `rotate(${angle}deg)`;
            rotateValue.textContent = `${angle}°`;
        });

        const idCell = row.querySelector(".frame-id-cell");
        idCell.addEventListener("blur", function () {
            const oldId = this.getAttribute("data-frame-id");
            const newIdCandidate = this.textContent.trim();
            if (newIdCandidate && newIdCandidate !== oldId) {
                const uniqueId = generateUniqueId(newIdCandidate);
                this.textContent = uniqueId;
                updateFrameId(oldId, uniqueId);
            } else if (!newIdCandidate) {
                this.textContent = oldId;
            }
        });

        const widthCell = row.cells[1];
        const heightCell = row.cells[2];
        widthCell.contentEditable = "true";
        heightCell.contentEditable = "true";
        widthCell.addEventListener("keypress", allowOnlyNumbers);
        heightCell.addEventListener("keypress", allowOnlyNumbers);
        widthCell.addEventListener("paste", filterPaste);
        heightCell.addEventListener("paste", filterPaste);
        widthCell.addEventListener("blur", function() {
            const newWidth = parseFloat(this.textContent);
            if (!isNaN(newWidth)) {
                const newWidthPx = newWidth * conversionFactors[currentUnit];
                const frameElem = document.getElementById(row.id.replace("-row", ""));
                if (frameElem) {
                    frameElem.style.width = newWidthPx + "px";
                    frameElem.dataset.origWidth = newWidthPx;
                    updateFrameSizeDisplay(frameElem);
                }
            } else {
                this.textContent = frameWidthInput;
            }
        });
        heightCell.addEventListener("blur", function() {
            const newHeight = parseFloat(this.textContent);
            if (!isNaN(newHeight)) {
                const newHeightPx = newHeight * conversionFactors[currentUnit];
                const frameElem = document.getElementById(row.id.replace("-row", ""));
                if (frameElem) {
                    frameElem.style.height = newHeightPx + "px";
                    frameElem.dataset.origHeight = newHeightPx;
                    updateFrameSizeDisplay(frameElem);
                }
            } else {
                this.textContent = frameHeightInput;
            }
        });
        updateFrameSizeDisplay(frame);
    });

    function allowOnlyNumbers(e) {
        if (e.ctrlKey || e.metaKey || e.altKey) return;
        if (["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(e.key)) return;
        const currentValue = e.target.textContent || "";
        if (e.key === "-" || e.key === "–") {
            e.preventDefault();
            return;
        }
        if (/[0-9]/.test(e.key)) return;
        if (e.key === "." && currentValue.indexOf(".") === -1) return;
        e.preventDefault();
    }

    // Updated filterPaste function
    function filterPaste(e) {
        e.preventDefault();
        const text = (e.clipboardData || window.clipboardData).getData("text");
        const filtered = text.replace(/[^0-9.]/g, "");
        document.execCommand("insertText", false, filtered);
    }

    function deleteFrame(frameId) {
        const frame = document.getElementById(frameId);
        if (frame) paper.removeChild(frame);
        const row = document.getElementById(frameId + "-row");
        if (row) frameList.removeChild(row);
        frameHistory = frameHistory.filter(id => id !== frameId);
    }

    document.getElementById("deleteAllFrames").addEventListener("click", () => {
        while (paper.firstChild) {
            paper.removeChild(paper.firstChild);
        }
        frameList.innerHTML = "";
        frameHistory = [];
        frameCount = 0;
    });

    document.getElementById("undoAction").addEventListener("click", () => {
        if (frameHistory.length > 0) {
            const lastFrameId = frameHistory.pop();
            deleteFrame(lastFrameId);
        } else {
            alert("No actions to undo.");
        }
    });

    document.getElementById("organizeBtn").addEventListener("click", organizeFrames);

    function organizeFrames() {
        const marginInputVal = parseFloat(document.getElementById("marginInput").value) || 0;
        const margin = marginInputVal * conversionFactors[currentUnit];
        const allowRotation = document.getElementById("allowRotation").checked;

        // Gather frames data
        const frameElements = Array.from(document.getElementsByClassName("frame"));
        const frames = frameElements.map(frame => {
            const origW = parseFloat(frame.dataset.origWidth);
            const origH = parseFloat(frame.dataset.origHeight);
            return {
                element: frame,
                origWidth: origW,
                origHeight: origH,
                rawWidth: origW,
                rawHeight: origH
            };
        });

        // Sort frames by area in descending order for better packing
        frames.sort((a, b) => (b.origWidth * b.origHeight) - (a.origWidth * a.origHeight));

        // Maximal Rectangles packing algorithm
        function maximalRectanglesPacking(binWidth) {
            // Deep copy frames array to work with
            const layoutFrames = JSON.parse(JSON.stringify(frames));

            // Initialize with a single maximal rectangle covering the entire bin
            const freeRectangles = [{
                x: margin,
                y: margin,
                width: binWidth - 2*margin,
                height: Number.MAX_SAFE_INTEGER
            }];

            let binHeight = margin; // Start with margin at the top
            let maxRightEdge = margin; // Track the rightmost edge of all placed frames

            // Place each frame
            layoutFrames.forEach(frame => {
                // Find best position for this frame
                const placement = findBestPlacement(frame, freeRectangles, allowRotation, margin);

                if (placement) {
                    // Apply the placement (positions already include margin space)
                    frame.posX = placement.x;
                    frame.posY = placement.y;
                    frame.usedWidth = placement.width;
                    frame.usedHeight = placement.height;
                    frame.rotated = placement.rotated;

                    // Update bin height - add margin to placement height for boundary
                    binHeight = Math.max(binHeight, placement.y + placement.height + margin);

                    // Update max right edge
                    maxRightEdge = Math.max(maxRightEdge, placement.x + placement.width + margin);

                    // Update free rectangles - note that we include margin in the space taken
                    placeRectangle({
                        x: placement.x - margin,  // Expand by margin for spacing
                        y: placement.y - margin,  // Expand by margin for spacing
                        width: placement.width + 2*margin,  // Add margins on both sides
                        height: placement.height + 2*margin  // Add margins on both sides
                    }, freeRectangles);
                } else {
                    // If we can't place it, put it at the bottom
                    frame.posX = margin;
                    frame.posY = binHeight;
                    frame.usedWidth = frame.origWidth;
                    frame.usedHeight = frame.origHeight;
                    frame.rotated = false;

                    // Update max right edge
                    maxRightEdge = Math.max(maxRightEdge, frame.posX + frame.origWidth + margin);

                    binHeight += frame.origHeight + margin;

                    // Create new free rectangles on the sides of this one (include margin in used space)
                    if (frame.origWidth + 2*margin < binWidth - 2*margin) {
                        freeRectangles.push({
                            x: margin + frame.origWidth + margin, // Add margin spacing
                            y: frame.posY - margin, // Back up for margin space
                            width: binWidth - 2*margin - (frame.origWidth + margin),
                            height: frame.origHeight + 2*margin
                        });
                    }
                }
            });

            // Calculate actual needed width (at least the margin + maxRightEdge)
            const actualNeededWidth = Math.min(binWidth, maxRightEdge);

            return {
                usedWidth: actualNeededWidth,
                usedHeight: binHeight,
                layoutFrames: layoutFrames
            };
        }

        // Function to find the best placement for a frame
        function findBestPlacement(frame, freeRectangles, allowRotation, margin) {
            let bestScore = -Infinity;
            let bestRect = null;
            let bestRotated = false;

            // Heuristic methods for selecting placement
            const bestFitMethod = "best-short-side-fit"; // Options: "best-area-fit", "best-short-side-fit", "best-long-side-fit"

            // Try each free rectangle
            for (const rect of freeRectangles) {
                // Try normal orientation
                if (frame.origWidth <= rect.width && frame.origHeight <= rect.height) {
                    const score = scoreRectangle(rect.width, rect.height, frame.origWidth, frame.origHeight, bestFitMethod);
                    if (score > bestScore) {
                        bestScore = score;
                        bestRect = rect;
                        bestRotated = false;
                    }
                }

                // Try rotated orientation if allowed
                if (allowRotation && frame.origHeight <= rect.width && frame.origWidth <= rect.height) {
                    const score = scoreRectangle(rect.width, rect.height, frame.origHeight, frame.origWidth, bestFitMethod);
                    if (score > bestScore) {
                        bestScore = score;
                        bestRect = rect;
                        bestRotated = true;
                    }
                }
            }

            if (bestRect) {
                // Width and height that will actually be used
                const width = bestRotated ? frame.origHeight : frame.origWidth;
                const height = bestRotated ? frame.origWidth : frame.origHeight;

                return {
                    x: bestRect.x,
                    y: bestRect.y,
                    width: width,
                    height: height,
                    rotated: bestRotated
                };
            }

            return null;
        }

        // Score a potential placement
        function scoreRectangle(rectWidth, rectHeight, frameWidth, frameHeight, method) {
            const areaFit = rectWidth * rectHeight - frameWidth * frameHeight;

            switch (method) {
                case "best-area-fit":
                    return -areaFit; // Smaller leftover area is better
                case "best-short-side-fit":
                    return -Math.min(rectWidth - frameWidth, rectHeight - frameHeight);
                case "best-long-side-fit":
                    return -Math.max(rectWidth - frameWidth, rectHeight - frameHeight);
                default:
                    return -areaFit;
            }
        }

        // Update free rectangles after placing a rectangle
        function placeRectangle(placement, freeRectangles) {
            // Split free rectangles that overlap with the placement
            const newFreeRectangles = [];

            for (let i = 0; i < freeRectangles.length; i++) {
                const free = freeRectangles[i];

                // If no overlap, keep the rectangle as is
                if (placement.x + placement.width <= free.x ||
                    placement.x >= free.x + free.width ||
                    placement.y + placement.height <= free.y ||
                    placement.y >= free.y + free.height) {
                    newFreeRectangles.push(free);
                    continue;
                }

                // We have overlap - split the free rectangle into up to 4 new ones

                // Left of placement
                if (placement.x > free.x) {
                    newFreeRectangles.push({
                        x: free.x,
                        y: free.y,
                        width: placement.x - free.x,
                        height: free.height
                    });
                }

                // Right of placement
                if (free.x + free.width > placement.x + placement.width) {
                    newFreeRectangles.push({
                        x: placement.x + placement.width,
                        y: free.y,
                        width: free.x + free.width - (placement.x + placement.width),
                        height: free.height
                    });
                }

                // Above placement
                if (placement.y > free.y) {
                    newFreeRectangles.push({
                        x: free.x,
                        y: free.y,
                        width: free.width,
                        height: placement.y - free.y
                    });
                }

                // Below placement
                if (free.y + free.height > placement.y + placement.height) {
                    newFreeRectangles.push({
                        x: free.x,
                        y: placement.y + placement.height,
                        width: free.width,
                        height: free.y + free.height - (placement.y + placement.height)
                    });
                }
            }

            // Replace the old free rectangles with the new ones
            freeRectangles.length = 0;

            // Filter out contained rectangles
            for (const rect of newFreeRectangles) {
                if (!isRectangleContained(rect, newFreeRectangles)) {
                    freeRectangles.push(rect);
                }
            }

            // Merge overlapping free rectangles to reduce their number
            mergeFreeRectangles(freeRectangles);
        }

        // Check if a rectangle is contained within any other rectangle
        function isRectangleContained(rect, rectangles) {
            for (const other of rectangles) {
                if (other !== rect &&
                    rect.x >= other.x &&
                    rect.y >= other.y &&
                    rect.x + rect.width <= other.x + other.width &&
                    rect.y + rect.height <= other.y + other.height) {
                    return true;
                }
            }
            return false;
        }

        // Merge overlapping free rectangles to reduce fragmentation
        function mergeFreeRectangles(freeRectangles) {
            // Sort rectangles by area in descending order
            freeRectangles.sort((a, b) => (b.width * b.height) - (a.width * a.height));

            // This is a simplified merge that removes redundant rectangles
            for (let i = 0; i < freeRectangles.length; i++) {
                const rect = freeRectangles[i];
                for (let j = i + 1; j < freeRectangles.length; j++) {
                    const other = freeRectangles[j];

                    // Check if other is fully contained in rect
                    if (other.x >= rect.x &&
                        other.y >= rect.y &&
                        other.x + other.width <= rect.x + rect.width &&
                        other.y + other.height <= rect.y + rect.height) {
                        freeRectangles.splice(j, 1);
                        j--;
                    }
                }
            }
        }

        // Get paper dimensions in px
        const paperWpx = parseFloat(document.getElementById("paperWidth").value) * conversionFactors[currentUnit];
        const paperHpx = parseFloat(document.getElementById("paperHeight").value) * conversionFactors[currentUnit];

        // Try both orientations
        const normalResult = maximalRectanglesPacking(paperWpx);
        const normalArea = normalResult.usedWidth * normalResult.usedHeight;

        const swappedResult = maximalRectanglesPacking(paperHpx);
        const swappedArea = swappedResult.usedWidth * swappedResult.usedHeight;

        // Pick the better layout
        let finalLayout, finalWpx, finalHpx;
        if (swappedArea < normalArea) {
            finalLayout = swappedResult.layoutFrames;
            finalWpx = swappedResult.usedWidth;
            finalHpx = swappedResult.usedHeight;
        } else {
            finalLayout = normalResult.layoutFrames;
            finalWpx = normalResult.usedWidth;
            finalHpx = normalResult.usedHeight;
        }

        // Apply the best layout
        finalLayout.forEach((f, i) => {
            const element = frames[i].element;

            if (f.rotated) {
                // For rotated elements, we need to adjust the position and dimensions
                // to compensate for how CSS transforms work

                // When rotating 90 degrees, we need to:
                // 1. Set width and height to the swapped dimensions
                // 2. Use "transform-origin: top left" to rotate around top-left corner
                // 3. Adjust positioning to account for the rotation

                element.style.width = f.usedHeight + "px"; // Note: we swap width/height
                element.style.height = f.usedWidth + "px";
                element.style.left = f.posX + "px";
                element.style.top = f.posY + "px";
                element.style.transformOrigin = "top left";
                element.style.transform = "rotate(90deg) translate(0, -100%)";

                // Update table row if it exists
                const row = document.getElementById(element.id + "-row");
                if (row) {
                    row.cells[1].textContent = (f.usedHeight / conversionFactors[currentUnit]).toFixed(2);
                    row.cells[2].textContent = (f.usedWidth / conversionFactors[currentUnit]).toFixed(2);
                    row.cells[4].querySelector(".rotate-value").textContent = "90°";
                    row.cells[4].querySelector(".rotate-slider").value = 90;
                }
            } else {
                // For non-rotated elements, positioning is straightforward
                element.style.width = f.usedWidth + "px";
                element.style.height = f.usedHeight + "px";
                element.style.left = f.posX + "px";
                element.style.top = f.posY + "px";
                element.style.transform = "rotate(0deg)";
                element.style.transformOrigin = "center"; // reset to default

                // Update table row if it exists
                const row = document.getElementById(element.id + "-row");
                if (row) {
                    row.cells[4].querySelector(".rotate-value").textContent = "0°";
                    row.cells[4].querySelector(".rotate-slider").value = 0;
                }
            }
        });

        // Set final paper dimensions
        paper.style.width = finalWpx + "px";
        paper.style.height = finalHpx + "px";

        // Display final size in current unit
        const displayedW = finalWpx / conversionFactors[currentUnit];
        const displayedH = finalHpx / conversionFactors[currentUnit];
        const paperSizeOutput = document.getElementById("paperSizeOutput");
        paperSizeOutput.textContent = `Paper Size: ${displayedW.toFixed(2)} ${currentUnit} x ${displayedH.toFixed(2)} ${currentUnit}`;
        updateAllFrameSizeDisplays();
    }

    document.addEventListener('DOMContentLoaded', function() {
        // For all input[type="number"] elements
        const numericInputs = document.querySelectorAll('input[type="number"]');
        numericInputs.forEach(input => {
            // Set min attribute to 0 to prevent negative values
            input.setAttribute('min', '0');

            // Add event handler for direct entry validation
            input.addEventListener('input', function() {
                if (this.value < 0) {
                    this.value = 0;
                }
            });

            // Prevent minus key
            input.addEventListener('keydown', function(e) {
                if (e.key === '-' || e.key === 'e') {
                    e.preventDefault();
                }
            });
        });
    });

    // Global variable to track if size display is enabled
    let showFrameSizes = true;

    // Function to create or update the size display for a frame
    function updateFrameSizeDisplay(frame) {
        // Get the frame's dimensions in the current unit
        const widthPx = parseFloat(frame.style.width);
        const heightPx = parseFloat(frame.style.height);
        const widthInUnit = (widthPx / conversionFactors[currentUnit]).toFixed(2);
        const heightInUnit = (heightPx / conversionFactors[currentUnit]).toFixed(2);

        // Check if the frame already has a size display
        let sizeDisplay = frame.querySelector('.frame-size-display');

        // If no display exists and showing is enabled, create one
        if (!sizeDisplay && showFrameSizes) {
            sizeDisplay = document.createElement('div');
            sizeDisplay.className = 'frame-size-display';
            frame.appendChild(sizeDisplay);
        }

        // If sizeDisplay exists, update its content
        if (sizeDisplay) {
            sizeDisplay.textContent = `${widthInUnit} × ${heightInUnit} ${currentUnit}`;
            sizeDisplay.style.display = showFrameSizes ? 'block' : 'none';

            // Adjust position if frame is rotated
            let transform = frame.style.transform;
            if (transform.includes('rotate(90deg)')) {
                sizeDisplay.style.transform = 'rotate(-90deg)';
                sizeDisplay.style.transformOrigin = 'left top';
                sizeDisplay.style.top = '50%';
                sizeDisplay.style.left = '10px';
            } else {
                sizeDisplay.style.transform = '';
                sizeDisplay.style.top = '5px';
                sizeDisplay.style.left = '5px';
            }
        }
    }

    // Function to update all frame size displays
    function updateAllFrameSizeDisplays() {
        const frames = document.querySelectorAll('.frame');
        frames.forEach(frame => updateFrameSizeDisplay(frame));
    }

    // Toggle visibility of all frame size displays
    function toggleFrameSizes() {
        showFrameSizes = !showFrameSizes;
        updateAllFrameSizeDisplays();
    }




    function makeDraggable(element) {
        let initialX, initialY;
        element.addEventListener("mousedown", dragStart);
        document.addEventListener("mouseup", dragEnd);
        document.addEventListener("mousemove", drag);

        function dragStart(e) {
            initialX = e.clientX - parseInt(element.style.left, 10);
            initialY = e.clientY - parseInt(element.style.top, 10);
            element.classList.add("dragging");
            element.style.zIndex = 1000;
        }

        function drag(e) {
            if (element.classList.contains("dragging")) {
                let newX = e.clientX - initialX;
                let newY = e.clientY - initialY;
                const parentWidth = paper.clientWidth;
                const parentHeight = paper.clientHeight;
                const frameWidth = element.offsetWidth;
                const frameHeight = element.offsetHeight;
                newX = Math.max(0, Math.min(newX, parentWidth - frameWidth));
                newY = Math.max(0, Math.min(newY, parentHeight - frameHeight));
                element.style.left = newX + "px";
                element.style.top = newY + "px";
            }
        }

        function dragEnd() {
            element.classList.remove("dragging");
            element.style.zIndex = "";
            updateFrameSizeDisplay(element);
        }
    }

    // Add event listener for the toggle button
    document.getElementById('toggleFrameSizes').addEventListener('click', toggleFrameSizes);
</script>
</body>
</html>

